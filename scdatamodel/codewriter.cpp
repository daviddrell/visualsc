#include "codewriter.h"
#include <QDebug>

CodeWriter::CodeWriter(SCState* rootMachine,QString cFileName, QString hFileName):
    cFile(cFileName),
    hFile(hFileName),
    cOut(&cFile),
    hOut(&hFile),
    _rootMachine(rootMachine)
{
    QStringList qsl = cFileName.split("/");
    QString fName = qsl.at(qsl.size()-1);
    className = fName.mid(0,fName.size()-4);    // get the class name out of the entire file name
    qDebug() << "the class name is " << className;
   // cOut = new QTextStream(&cFile);
  //  hOut = new QTextStream(&hFile);
}

bool CodeWriter::helloWorld()
{
    if(!cFile.open(QIODevice::WriteOnly|QIODevice::Text))
        return false;

    if(!hFile.open(QIODevice::WriteOnly|QIODevice::Text))
        return false;

    cOut << "//This is a cpp file\n\nvoid helloWorld()\n{\n\n}\n";

    hOut << "//This is an h file\n\nvoid helloWorld()\n{\n\n}\n";

    return true;
}

void CodeWriter::addState(SCState* state)
{
    _children.append(state);
}

void CodeWriter::addStateMachine(SCState* state)
{
    _childrenMachines.append(state);
}

void CodeWriter::setRootMachine(SCState* state)
{
    _rootMachine = state;
}

void CodeWriter::setChildren(QList<SCState*> states)
{
    _children = states;
}

bool CodeWriter::writeCppFile()
{
    if(!cFile.open(QIODevice::WriteOnly|QIODevice::Text))
    {
        qDebug() << "ERROR writing to .cpp file!";
        return false;
    }

    // write a code generated message
    cOut << "// This .cpp file was generated using VisualSC's Export Code Function\n\n";

    // write include statement
    cOut << "#include \"" << className << ".h\"\n\n";

    // write constructor
    cOut << className <<"::"<<className<<"()\n{\n\n}\n";

    // write deconstructor
    cOut << className <<"::~"<<className<<"()\n{\n\n}\n";


    // true if no complications
    return true;
}

bool CodeWriter::writeHFile()
{
    if(!hFile.open(QIODevice::WriteOnly|QIODevice::Text))
    {
        qDebug() << "ERROR writing to .h file!";
        return false;
    }


// intro
    hPrintln("// This header file was generated using VisualSC's Export Code Function\n");
    hPrintln("#ifndef "+ className.toUpper() + "_H\n#define "+className.toUpper()+"_H\n");
    hPrintln("#include <QObject>");
    hPrintln("#include <QStateMachine>");
    hPrintln("#include <QFinalState>\n");
    hPrintln("class "+className+" : public QObject");
    hPrintln("{");
    hPrintln("Q_OBJECT\n",1);
    hPrintln("//////////////////",1);
    hPrintln("//",1);
    hPrintln("//    Public interface",1);
    hPrintln("//",1);
    hPrintln("//    Connect to public slots to drive events into",1);
    hPrintln("//    the state machine",1);
    hPrintln("//",1);
    hPrintln("//    Connect to the public signals to do work",1);
    hPrintln("//    and monitor state changes",1);
    hPrintln("//",1);
    hPrintln("//////////////////\n",1);


// public
    hPrintln("public:");
    hPrintln(className+"(QObject*parent=NULL);",1);
    hPrintln("~"+className+"();\n",1);
    hPrintln("//",1);
    hPrintln("//    INPUT EVENT SLOTS",1);
    hPrintln("//",1);
    hPrintln("//    Call these slots to signal event inputs to the machine",1);
    hPrintln("//\n",1);

// public slots
    hPrintln("\npublic slots:\n");


// signals
    hPrintln("\nsignals:\n");
    hPrintln("//",1);
    hPrintln("//    OUTPUT ACTION SIGNALS",1);
    hPrintln("//",1);
    hPrintln("//    Connect to these signals to take actions",1);
    hPrintln("//\n",1);
    hPrintln("\n//",1);
    hPrintln("//    STATE CHANGE MONITOR SIGNALS",1);
    hPrintln("//",1);
    hPrintln("//    Connect to these signals to monitor state transitions",1);
    hPrintln("//\n",1);


// private alert
    hPrintln("\n//////////////////",1);
    hPrintln("//",1);
    hPrintln("//    Private below here",1);
    hPrintln("//",1);
    hPrintln("//////////////////\n",1);

// paragraph
    hPrintln("\n/*",1);
    hPrintln(" *  A consequence of OOB encapsulation is that this class does know about its users, and so cannot listen",1);
    hPrintln(" * to their signals. Therefore this class exposes public slots that users can call. These slots",1);
    hPrintln(" * are then translated into private signals that the private state machine can listen to.",1);
    hPrintln(" *",1);
    hPrintln(" * For outbound signals, I choose to keep the statemachine objects private so that means I need",1);
    hPrintln(" * to translate private state machine signals into public signals.",1);
    hPrintln(" *",1);
    hPrintln(" * This all leads to a lot of confusion and possible name collisions. Therefore its better for this",1);
    hPrintln(" * file to be autogenerated from the visual state chart editor.",1);
    hPrintln(" *",1);
    hPrintln(" */\n",1);


    hPrintln("\nprivate:\n");

// private slots
    hPrintln("\nprivate slots:\n");
    hPrintln("// these slots register the state entry/exits to generate action signals",1);

// signals
    hPrintln("\nsignals:\n");
    hPrintln("// these signals are inputs to the statemachine as relayed from the public facing slots",1);

// private members
    hPrintln("\nprivate:\n");


    //write the statemachine and states
    if(_rootMachine)
    {
        hPrintln("QStateMachine*    _" + toCamelCase(_rootMachine->attributes.value("name")->asString())+";",1);
    }
    for(int i = 0 ; i < _childrenMachines.count(); i++)
    {
        hPrintln("QStateMachine*    _" + toCamelCase(_childrenMachines.at(i)->attributes.value("name")->asString())+";",1);
    }
    for(int i = 0 ; i < _children.count(); i++)
    {
        hPrintln("QState*    _"+ toCamelCase(_children.at(i)->attributes.value("name")->asString())+";",1);
    }

// end if define
    hPrintln("\n};\n\n#endif // "+className.toUpper()+"_H");

    // true if no complications
    return true;

}

/**
 * @brief CodeWriter::toCamelCase
 * @param text
 * @return
 * converts any space separated string of words and returns a camel case string
 */
QString CodeWriter::toCamelCase(QString text)
{
    QStringList qls = text.split(" ");
    //if(qls.size()==1)
      //  return text;

    QString ret;
    QString part;

    ret+=qls.at(0).toLower();
    for(int i = 1 ; i < qls.size(); i++)
    {
        part = qls.at(i).toLower();
        ret+= part.at(0).toUpper();
        ret+= part.mid(1,part.size());
    }
    return ret;
}

void CodeWriter::hWriteEventSlots()
{
    SCState* state;
    SCTransition* trans;
    QList<SCTransition*> transitions;
    for(int i = 0 ; i < _children.count();i++)
    {
        // if we go through all out transitions, all transitions will be covered.
        state = _children.at(i);
        transitions.clear();
        state->getTransitions(transitions);
        for(int k = 0; k < transitions.count(); k++)
        {
            trans = transitions.at(k);
            hPrintln("Event_"+toCamelCase(trans->attributes.value("event")->asString())+"();");
        }
    }
}

void CodeWriter::hPrint(QString text)
{
    hOut << text;
}

void CodeWriter::hPrintln(QString text)
{
    hOut << text <<"\n";
}

void CodeWriter::hPrintln(QString text, int tabLevel)
{
    if(text.at(0)=='\n')
    {
        hOut << "\n";
        for(int i = 0 ; i < tabLevel; i++)
        {
            hOut << "    ";
        }
        hOut << text.mid(1,text.size()) <<"\n";
    }
    else
    {
        for(int i = 0 ; i < tabLevel; i++)
        {
            hOut << "    ";
        }
        hOut << text <<"\n";
    }
}

void CodeWriter::cPrint(QString text)
{
    cOut << text;
}

void CodeWriter::cPrintln(QString text)
{
    cOut << text <<"\n";
}

void CodeWriter::cPrintln(QString text, int tabLevel)
{
    if(text.at(0)=='\n')
    {
        cOut << "\n";
        for(int i = 0 ; i < tabLevel; i++)
        {
            cOut << "    ";
        }
        cOut << text.mid(1,text.size()) <<"\n";
    }
    else
    {
        for(int i = 0 ; i < tabLevel; i++)
        {
            cOut << "    ";
        }
        cOut << text <<"\n";
    }
}


CodeWriter::~CodeWriter()
{

}

