// This header file was generated using VisualSC's Export Code Function

// Visual Statechart is an open source project. Visit us at https://github.com/daviddrell/visualsc
#ifndef STATESEQUENCEMACHINE_H
#define STATESEQUENCEMACHINE_H

#include <QObject>
#include <QStateMachine>
#include <QFinalState>

class StateSequenceMachine : public QObject
{
    Q_OBJECT

    //////////////////
    //
    //    Public interface
    //
    //    Connect to public slots to drive events into
    //    the state machine
    //
    //    Connect to the public signals to do work
    //    and monitor state changes
    //
    //////////////////

public:
    StateSequenceMachine(QObject*parent=NULL);
    ~StateSequenceMachine();

    //
    //    INPUT EVENT SLOTS
    //
    //    Call these slots to signal event inputs to the machine
    //


public slots:
    //////// State Machine: _stateSequenceMachine ////////
    void Event_startMachine_stateSequenceMachine();
    void Event_checkingAllStatesCompleted_914678f0();
    void Event_checkingCallSequenceFailed_51ea86cc();
    void Event_checkingConnSequenceFailed_51ea86cc();
    void Event_checkingSessionSeqFailed_51ea86cc();

    //////// State Machine: _checkingAllStateSequences ////////

    //////// State Machine: _checkingCallSequence ////////
    void Event_callSeqComplete_0b1b5af8();

    //////// State Machine: _checkingConnSequence ////////
    void Event_connSeqComplete_57b5d5f6();

    //////// State Machine: _checkingSessionSeq ////////
    void Event_sessionSeqComplete_3967534e();


signals:
    //
    //    OUTPUT ACTION SIGNALS
    //
    //    Connect to these signals to a slot corresponding to a entryAction or exitAction
    //
    //////// State Machine: _stateSequenceMachine ////////

    //////// State Machine: _checkingAllStateSequences ////////

    //////// State Machine: _checkingCallSequence ////////

    //////// State Machine: _checkingConnSequence ////////

    //////// State Machine: _checkingSessionSeq ////////


    //
    //    STATE CHANGE MONITOR SIGNALS
    //
    //    Connect to these signals to monitor state transitions
    //
    //////// State Machine: _stateSequenceMachine ////////
    void Signal_StateReady_stateSequenceMachine();
    void Signal_StateEntry_checkingAllStateSequences();
    void Signal_StateExit_checkingAllStateSequences();
    void Signal_StateEntry_failed();
    void Signal_StateExit_failed();
    void Signal_StateEntry_success();
    void Signal_StateExit_success();

    //////// State Machine: _checkingAllStateSequences ////////
    void Signal_StateEntry_checkingCallSequence();
    void Signal_StateExit_checkingCallSequence();
    void Signal_StateEntry_checkingConnSequence();
    void Signal_StateExit_checkingConnSequence();
    void Signal_StateEntry_checkingSessionSeq();
    void Signal_StateExit_checkingSessionSeq();

    //////// State Machine: _checkingCallSequence ////////
    void Signal_StateEntry_waiting___checkingCallSequence();
    void Signal_StateExit_waiting___checkingCallSequence();
    void Signal_StateEntry_completed___checkingCallSequence();
    void Signal_StateExit_completed___checkingCallSequence();

    //////// State Machine: _checkingConnSequence ////////
    void Signal_StateEntry_waiting___checkingConnSequence();
    void Signal_StateExit_waiting___checkingConnSequence();
    void Signal_StateEntry_completed___checkingConnSequence();
    void Signal_StateExit_completed___checkingConnSequence();

    //////// State Machine: _checkingSessionSeq ////////
    void Signal_StateEntry_waiting();
    void Signal_StateExit_waiting();
    void Signal_StateEntry_completed();
    void Signal_StateExit_completed();


    //////////////////
    //
    //    Private below here
    //
    //////////////////


    /*
     *  A consequence of OOB encapsulation is that this class does know about its users, and so cannot listen
     * to their signals. Therefore this class exposes public slots that users can call. These slots
     * are then translated into private signals that the private state machine can listen to.
     *
     * For outbound signals, I choose to keep the statemachine objects private so that means I need
     * to translate private state machine signals into public signals.
     *
     * This all leads to a lot of confusion and possible name collisions. Therefore its better for this
     * file to be autogenerated from the visual state chart editor.
     *
     */


private:


private slots:
    // The Entry/Exit Slots that belong to QStates
    //////// State Machine: _stateSequenceMachine ////////
    void Slot_StateEntry_checkingAllStateSequences();
    void Slot_StateExit_checkingAllStateSequences();
    void Slot_StateEntry_failed();
    void Slot_StateExit_failed();
    void Slot_StateEntry_success();
    void Slot_StateExit_success();

    //////// State Machine: _checkingAllStateSequences ////////
    void Slot_StateEntry_checkingCallSequence();
    void Slot_StateExit_checkingCallSequence();
    void Slot_StateEntry_checkingConnSequence();
    void Slot_StateExit_checkingConnSequence();
    void Slot_StateEntry_checkingSessionSeq();
    void Slot_StateExit_checkingSessionSeq();

    //////// State Machine: _checkingCallSequence ////////
    void Slot_StateEntry_waiting___checkingCallSequence();
    void Slot_StateExit_waiting___checkingCallSequence();
    void Slot_StateEntry_completed___checkingCallSequence();
    void Slot_StateExit_completed___checkingCallSequence();

    //////// State Machine: _checkingConnSequence ////////
    void Slot_StateEntry_waiting___checkingConnSequence();
    void Slot_StateExit_waiting___checkingConnSequence();
    void Slot_StateEntry_completed___checkingConnSequence();
    void Slot_StateExit_completed___checkingConnSequence();

    //////// State Machine: _checkingSessionSeq ////////
    void Slot_StateEntry_waiting();
    void Slot_StateExit_waiting();
    void Slot_StateEntry_completed();
    void Slot_StateExit_completed();


signals:
    // A Transition/Event slot's corresponding signal emitted in the slot
    //////// State Machine: _stateSequenceMachine ////////
    void Relay_Event_checkingAllStatesCompleted_914678f0();
    void Relay_Event_checkingCallSequenceFailed_51ea86cc();
    void Relay_Event_checkingConnSequenceFailed_51ea86cc();
    void Relay_Event_checkingSessionSeqFailed_51ea86cc();

    //////// State Machine: _checkingAllStateSequences ////////

    //////// State Machine: _checkingCallSequence ////////
    void Relay_Event_callSeqComplete_0b1b5af8();

    //////// State Machine: _checkingConnSequence ////////
    void Relay_Event_connSeqComplete_57b5d5f6();

    //////// State Machine: _checkingSessionSeq ////////
    void Relay_Event_sessionSeqComplete_3967534e();


private:
    //////// State Machine: _stateSequenceMachine ////////
    QStateMachine*    _stateSequenceMachine;
    QState*    _checkingAllStateSequences;
    QFinalState*    _failed;
    QFinalState*    _success;

    //////// State Machine: _checkingAllStateSequences ////////
    // child QState declared elsewhere _checkingAllStateSequences
    QState*    _checkingCallSequence;
    QState*    _checkingConnSequence;
    QState*    _checkingSessionSeq;

    //////// State Machine: _checkingCallSequence ////////
    // child QState declared elsewhere _checkingCallSequence
    QState*    _waiting___checkingCallSequence;
    QFinalState*    _completed___checkingCallSequence;

    //////// State Machine: _checkingConnSequence ////////
    // child QState declared elsewhere _checkingConnSequence
    QState*    _waiting___checkingConnSequence;
    QFinalState*    _completed___checkingConnSequence;

    //////// State Machine: _checkingSessionSeq ////////
    // child QState declared elsewhere _checkingSessionSeq
    QState*    _waiting;
    QFinalState*    _completed;


};

#endif // STATESEQUENCEMACHINE_H
