// This header file was generated using VisualSC's Export Code Function

// Visual Statechart is an open source project. Visit us at https://github.com/daviddrell/visualsc
#ifndef STATEMACHINE_H
#define STATEMACHINE_H

#include <QObject>
#include <QStateMachine>
#include <QFinalState>

class StateMachine : public QObject
{
    Q_OBJECT

    //////////////////
    //
    //    Public interface
    //
    //    Connect to public slots to drive events into
    //    the state machine
    //
    //    Connect to the public signals to do work
    //    and monitor state changes
    //
    //////////////////

public:
    StateMachine(QObject*parent=NULL);
    ~StateMachine();

    //
    //    INPUT EVENT SLOTS
    //
    //    Call these slots to signal event inputs to the machine
    //


public slots:
    //////// State Machine: _stateMachine ////////
    void Event_startMachine___stateMachine();
    void Event___systemReady();
    void Event___equipmentFailed();

    //////// State Machine: _running ////////

    //////// State Machine: _looping ////////
    void Event___disconnected();
    void Event___disconnectFailed();
    void Event___connected();
    void Event___dialFailed();
    void Event___unregistered();
    void Event___registered();
    void Event___loopCountExceeded();
    void Event___loopCountNotExceeded();


signals:
    //
    //    OUTPUT ACTION SIGNALS
    //
    //    Connect to these signals to a slot corresponding to a entryAction or exitAction
    //
    //////// State Machine: _stateMachine ////////

    //////// State Machine: _running ////////

    //////// State Machine: _looping ////////
    void Action___hangup();
    void Action___dial();
    void Action___deregister();
    void Action___register();
    void Action___incrementloopcount();


    //
    //    STATE CHANGE MONITOR SIGNALS
    //
    //    Connect to these signals to monitor state transitions
    //
    //////// State Machine: _stateMachine ////////
    void Signal_StateReady___stateMachine();
    void Signal_StateEntry___waitingForSystemReady();
    void Signal_StateExit___waitingForSystemReady();
    void Signal_StateEntry___running();
    void Signal_StateExit___running();
    void Signal_StateEntry___success();
    void Signal_StateExit___success();
    void Signal_StateEntry___failed();
    void Signal_StateExit___failed();

    //////// State Machine: _running ////////
    void Signal_StateEntry___looping();
    void Signal_StateExit___looping();

    //////// State Machine: _looping ////////
    void Signal_StateEntry___connected();
    void Signal_StateExit___connected();
    void Signal_StateEntry___connecting();
    void Signal_StateExit___connecting();
    void Signal_StateEntry___disconnected();
    void Signal_StateExit___disconnected();
    void Signal_StateEntry___registering();
    void Signal_StateExit___registering();
    void Signal_StateEntry___unregistered();
    void Signal_StateExit___unregistered();


    //////////////////
    //
    //    Private below here
    //
    //////////////////


    /*
     *  A consequence of OOB encapsulation is that this class does know about its users, and so cannot listen
     * to their signals. Therefore this class exposes public slots that users can call. These slots
     * are then translated into private signals that the private state machine can listen to.
     *
     * For outbound signals, I choose to keep the statemachine objects private so that means I need
     * to translate private state machine signals into public signals.
     *
     * This all leads to a lot of confusion and possible name collisions. Therefore its better for this
     * file to be autogenerated from the visual state chart editor.
     *
     */


private:


private slots:
    // The Entry/Exit Slots that belong to QStates
    //////// State Machine: _stateMachine ////////
    void Slot_StateEntry___waitingForSystemReady();
    void Slot_StateExit___waitingForSystemReady();
    void Slot_StateEntry___running();
    void Slot_StateExit___running();
    void Slot_StateEntry___success();
    void Slot_StateExit___success();
    void Slot_StateEntry___failed();
    void Slot_StateExit___failed();

    //////// State Machine: _running ////////
    void Slot_StateEntry___looping();
    void Slot_StateExit___looping();

    //////// State Machine: _looping ////////
    void Slot_StateEntry___connected();
    void Slot_StateExit___connected();
    void Slot_StateEntry___connecting();
    void Slot_StateExit___connecting();
    void Slot_StateEntry___disconnected();
    void Slot_StateExit___disconnected();
    void Slot_StateEntry___registering();
    void Slot_StateExit___registering();
    void Slot_StateEntry___unregistered();
    void Slot_StateExit___unregistered();


signals:
    // A Transition/Event slot's corresponding signal emitted in the slot
    //////// State Machine: _stateMachine ////////
    void Relay_Event___systemReady_waitingForSystemReady();
    void Relay_Event___equipmentFailed_running();

    //////// State Machine: _running ////////

    //////// State Machine: _looping ////////
    void Relay_Event___disconnected_connected();
    void Relay_Event___disconnectFailed_connected();
    void Relay_Event___connected_connecting();
    void Relay_Event___dialFailed_connecting();
    void Relay_Event___unregistered_disconnected();
    void Relay_Event___registered_registering();
    void Relay_Event___loopCountExceeded_unregistered();
    void Relay_Event___loopCountNotExceeded_unregistered();


private:
    //////// State Machine: _stateMachine ////////
    QStateMachine*    _stateMachine;
    QState*    _waitingForSystemReady;
    QState*    _running;
    QFinalState*    _success;
    QFinalState*    _failed;

    //////// State Machine: _running ////////
    // child QState declared elsewhere _running
    QState*    _looping;

    //////// State Machine: _looping ////////
    // child QState declared elsewhere _looping
    QState*    _connected;
    QState*    _connecting;
    QState*    _disconnected;
    QState*    _registering;
    QState*    _unregistered;


};

#endif // STATEMACHINE_H
